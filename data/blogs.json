[
  {
    "id": 1,
    "title": "What is CORS?",
    "slug": "what-is-cors",
    "short_details": "As you've possibly already come across by now, CORS is an acronym for Cross-Origin Resource Sharing, but what does that actually mean?",
    "description": "<div> <p>As you've possibly already come across by now, CORS is an acronym for Cross-Origin Resource Sharing, but what does that actually mean? What is CORS? Well, if we go by the <a href='https://en.wikipedia.org/wiki/Cross-origin_resource_sharing' target='_blank' rel='noopener noreferrer'> <u>Wikipedia definition</u> </a>, '[CORS] is a mechanism that allows restricted resources on a web page to be requested from another domain outside the domain from which the first resource was served,' then you'd be forgiven if you were more confused than before you'd read that sentence. </p> <p>Before we get into defining CORS, it's best to know what came before, as it still defines the default behavior and is probably why you're reading this now. This precursor to CORS was called the 'Same-Origin' policy. In short, it dictates that when your browser loads a script (like a button handler, or some async widget) from a particular (sub)domain that the script can only make requests to the (sub)domain that it originated from.</p> <h2 id='crossorigin-resource-sharing'>Cross-Origin Resource Sharing</h2> <p>So then, what is CORS? Simply put, CORS is the mechanism that provides the ability to alter the behavior of this policy, enabling you to do things like hosting static content at <a href='https://www.example.com/' target='_blank' rel='noopener noreferrer'> <u>www.example.com</u> </a> and the backend API at <a href='https://api.example.com/' target='_blank' rel='noopener noreferrer'> <u>api.example.com</u> </a>. This kind of request would be called a Cross-Origin request, as a resource from one subdomain is requesting a resource from another subdomain. </p> <p>This is all controlled through preflight requests that exchange a set of HTTP request headers and corresponding response headers collectively referred to as 'CORS Headers', each of these headers modifies a different element of the Same-Origin policy to loosen the limitations it imposes.</p> <p>There's a lot of terrible advice out there (especially on popular forums) on how to set this up where the answers generally include some variant of brutally setting wildcard ' <code>*</code>' response headers regardless of the request headers provided in the pre-flight request. This article attempts to dispel some of the common misconceptions about Cross-Origin Resource Sharing and provide useful advice on how to get things working correctly. </p> <h2 id='how-does-cors-work'>How Does CORS Work?</h2> <p>As mentioned above the CORS workflow starts when a script loaded from one origin attempts to make a request to another origin (thus the name Cross-Origin Resource Sharing).</p> <script type='module'> const t = 'undefined' != typeof HTMLImageElement && 'loading' in HTMLImageElement.prototype; if (t) { const t = document.querySelectorAll('img[data-main-image]'); for (let e of t) { e.dataset.src && (e.setAttribute('src', e.dataset.src), e.removeAttribute('data-src')), e.dataset.srcset && (e.setAttribute('srcset', e.dataset.srcset), e.removeAttribute('data-srcset')); const t = e.parentNode.querySelectorAll('source[data-srcset]'); for (let e of t) e.setAttribute('srcset', e.dataset.srcset), e.removeAttribute('data-srcset'); e.complete && (e.style.opacity = 1, e.parentNode.parentNode.querySelector('[data-placeholder-image]').style.opacity = 0) } } </script> </div> <p>This workflow begins with the browser automatically making a preflight request to the external web server. This preflight request uses the HTTP method OPTIONS and has several HTTP headers that we'll go into detail on later. The external web server should then validate these preflight request headers to ensure that scripts from that origin are allowed to make the actual request to the resource using the nominated request method and custom request headers specified in the preflight request headers.</p> <p>Once verified the external web server should then respond with its own set of HTTP headers. These response headers define the range of acceptable origins, request methods, custom headers, whether or not it's acceptable to send any credentials (such as cookies, authentication headers, etc.), and how long the browser should keep the response for. This allows the browser to keep that response cached as a form of pre-validation for any future requests that the script might wish to make.</p> <h2 id='so-what-are-the-request-headers-and-what-do-they-do'>So What Are the Request Headers, and What Do They Do?</h2> <p>Access control request headers are fairly straight forward and for the most part pretty self-explanatory.</p> <ul> <li> <p>` <code>Origin</code>` – The (sub)domain that the script making the request was served to the browser from. </p> </li> <li> <p>` <code>Access-Control-Request-Method</code>` – The method that the script would like to use in the actual request to follow. </p> </li> <li> <p>` <code>Access-Control-Request-Headers</code>` – The custom headers that the browser expects to send along with the actual request to follow. </p> </li> </ul> <h3 id='at-a-bare-minimum'>At a Bare Minimum</h3> <p>The ` <code>Origin</code>` should be checked against an access list by the server to confirm that scripts from that origin are acceptable. This isn't going to stop 100% of attacks, but it should at least slow down and discourage attackers and significantly reduce the risk of an automated malicious advert attack being successful. If the ` <code>Origin</code>` header isn't a match to your access list, then it's a good canary that an attack might be incoming. </p> <p>The other easy thing to validate is that the ` <code>Access-Control-Request-Method</code>` is actually a supported HTTP method used in your API. As with the ` <code>Origin</code>` header, if it's not something your API supports, then you know something is going on. </p> <h3 id='helpful-canaries'>Helpful Canaries</h3> <p>Setting up validation failure alerts for both of these headers gives you a reliable early warning that an attack is incoming, allowing you to act quickly to protect your users.</p> <p>The ` <code>Access-Control-Request-Headers</code>` request header is unfortunately not very reliable, as the actual request might contain some, none, or more custom headers than the browser has recognized. So it's fairly safe to ignore it if everything else is valid, but you probably want to log it if either of the others fails, as it might be a useful signature for future requests originating from the attacker. </p> <h2 id='access-control-allow-headers-and-how-to-respond-to-a-cors-request'>Access Control Allow Headers and How to Respond to a CORS Request</h2> <p>The access control allow headers are a little more complicated than the request headers, this is mostly because of a lack of proper implementation of the standard in most browsers. But before we drill down into the problems and how to avoid them, let's first talk about what the headers are and what they do.</p> <ul> <li> <p>` <code>Access-Control-Allow-Origin</code>` – Provided that the `Origin` request header matches your access list then this header should reflect that request header's content. </p> </li> <li> <p>Access-Control-Allow-Credentials – This header is a boolean indicating to the browser whether or not it is acceptable for code from this Origin to send authentication credentials such as cookies or Authorization headers.</p> </li> <li> <p>Access-Control-Expose-Headers – This is a comma-separated list that indicates to the browser which headers from the server's response to the actual request should be exposed to the script making the request.</p> </li> <li> <p>Access-Control-Max-Age – The max-age header indicates how long the browser should retain the response to this cross-origin request's preflight check in its cache to reduce the overhead of future cross-origin requests.</p> </li> <li> <p>Access-Control-Allow-Methods – This header lists all of the methods that scripts coming from the (sub)domain stated in the Origin header should be allowed to make.</p> </li> <li> <p>Access-Control-Allow-Headers – If the preflight request contains an ` <code>Access-Control-Request-Header</code>` then this header should either reflect that content to the browser or respond with a wildcard. </p> </li> </ul> <h2 id='about-those-caveats'>About Those Caveats...</h2> <h3 id='accesscontrolalloworigin'> <code>`Access-control-allow-origin`</code> </h3> <p>At first blush, it might seem like the ` <code>Access-Control-Allow-Origin</code>` header would support something like a wildcard subdomain, or a comma-separated list that you could statically set to match all of the domains and subdomains that you want to support, as this would drastically reduce the number of times the browser might need to do preflight requests in a session. However, this is unfortunately not the case, and doing so will result in undefined behavior. This tends to be the origin of most of the bad advice on forums like stack-overflow. Because as strange as it might seem the standard does support a generic wildcard that simply disables this check in the browser altogether, so people jump on this as the easy answer. Putting user data at risk as a result. </p> <h3 id='whats-so-bad-about-the-wildcard'>What's So Bad About The Wildcard?</h3> <p>As mentioned earlier, setting ` <code>Access-control-allow-origin</code>` to ` <code>*</code>` effectively disables the same-origin policy. This means that the browser will allow almost any request to that cross-origin resource from any script that happens to be loaded. This might not seem so bad, because you trust all of the code you put on your site, right? But that's not the whole story, because the browser is now not filtering the origins, this means any code on any site (including malicious phishing sites) can actually make a request to that resource. </p> <p>Now, given that modern browsers are at least a little bit security conscious, if you did attempt to follow the wildcard copy-pasta that is all over popular forums and needed to use credentials such as Authorization HTTP headers or cookies, your cross-origin request will fail. This is because, in an attempt to at least partially fix this class of vulnerability, browsers don't allow you to set the ` <code>access-control-allow-credentials</code>` header if the ` <code>access-control-allow-origins</code>` is set to a wildcard. Which ultimately lead to the next bad idea that someone had: Sending your authentication token as a custom header – completely exposing user data to any malicious code. </p> <h3 id='cant-i-just-reflect-the-origin'>Can't I Just Reflect the Origin?</h3> <p>This solution while seeming smart on the surface, without any validation of the origin field, this blind reflection is actually considerably worse than the wildcard as it completely bypasses the browser's prevention of setting both the ` <code>access-control-allow-credentials</code>` header and alongside a wildcard&nbsp;` <code>access-control-allow-origins</code>` (because it's now not a wildcard from the browser's perspective). Adding authentication credentials to the list of potentially exposed data. </p> <h2 id='principals-of-an-attack'>Principals of an Attack</h2> <p>The risks and context of an attack depend on the nature of the misconfiguration and how you're authenticating requests. Modern browsers do their best to mitigate the impact of the most egregious configuration errors (i.e. using the wildcard policy). However, there are equivalents that still get through.</p> <p>Let's consider the worst-case scenario defined above, <strong> <i>blind reflection</i> </strong> as it is the easiest to exploit. </p> <p>In order to exploit a blind reflection, all you need is for a victim (one of the target's clients) to browse any site that you can control or inject malicious code into, from there your code can make requests as the victim with the browser transmitting any authentication cookies it needs to perform those requests.</p><script type='module'> const t = 'undefined' != typeof HTMLImageElement && 'loading' in HTMLImageElement.prototype; if (t) { const t = document.querySelectorAll('img[data-main-image]'); for (let e of t) { e.dataset.src && (e.setAttribute('src', e.dataset.src), e.removeAttribute('data-src')), e.dataset.srcset && (e.setAttribute('srcset', e.dataset.srcset), e.removeAttribute('data-srcset')); const t = e.parentNode.querySelectorAll('source[data-srcset]'); for (let e of t) e.setAttribute('srcset', e.dataset.srcset), e.removeAttribute('data-srcset'); e.complete && (e.style.opacity = 1, e.parentNode.parentNode.querySelector('[data-placeholder-image]').style.opacity = 0) } } </script> </div> <p>Diagram of a successful attack profile.</p> <p>So what happened in this example? First, the victim navigates to a malicious site (this could be due to a phishing e-mail, or even just browsing a website with a malicious advert). When the page loads the browser runs the javascript on the page. This 'evil.js' then makes a request to the vulnerable target to which the browser (having validated the CORS headers from the target) dutifully attaches the victim's cookies for that resource. When the target then responds, 'evil.js' then forwards this response to the malicious website.&nbsp;</p> <p>The attack doesn't have to stop here either, include some C&amp;C code to evil.js and it could start relaying any command on behalf of the malicious site to the vulnerable site.</p> <p>As <a href='https://ejj.io/misconfigured-cors' target='_blank' rel='noopener noreferrer'> <u>others have shown</u> </a> as far back as 2016, this was a fairly common vulnerability, and only takes one mistake in some regex. Unfortunately, this is seemingly still the case. </p> <h2 id='what-is-the-best-practice-to-enable-cors-then'>What is the Best Practice to Enable CORS Then?</h2> <p>In order to ensure both that the script comes from an origin that you expect to be making valid requests to the cross-origin resource and that the browser won't just allow every script it loads to contact that resource. You should be validating all of the access control request headers against appropriate access lists. The implementation of this can be a little tricky, especially with the origin header, and the web is full of minor misconfigurations in parsing methods and bad regex that leaves all sorts of sites exposed to manipulation by an attacker. But, if you keep it simple, you can do it safely with a secure string comparison against an array of trusted values. If it doesn't perfectly match your lists then respond with a `403 Forbidden`.</p> <p>If we want to support more than one ` <code>Origin</code>,` then until browsers support a list of origins in the ` <code>access-control-allow-origin header</code>,` we don't really have a lot of choice but to reflect the validated ` <code>Origin</code>` request header into the ` <code>access-control-allow-origin header</code>.` </p> <h3 id='libraries-frameworks-reverseproxies'>Libraries, Frameworks, &amp; Reverse-Proxies</h3> <p>For most languages and web frameworks there is a pre-built solution that should handle all of this for you securely so that you don't have to. But there are a few that don't implement proper validation, so you do need to validate the library operates as expected before trusting it.</p> <p>Another alternative is to use an established web server like Nginx or Apache as a reverse proxy and use its filter rules to suitably reflect the headers if they satisfy the validation. Though, since these use regex for their validation filters, you have to be very careful when constructing your search string to ensure that you are safely validating the entire string matches your expectations. As a lot of companies that go this way seem to manage to introduce mistakes here.</p> <h2 id='further-reading'>Further Reading</h2> <p>For more background on exploiting misconfigured Cross-Origin resources and Tutorials on how to get it set up for correctly the framework you use, keep an eye open for more articles here.&nbsp;</p> <p>In the meantime, you might want to read one of our other articles on XSS in:</p> <ul> <li> <p> <u></u> <a href='https://www.stackhawk.com/blog/laravel-xss/'> <u>Laravel</u> </a> </p> </li> <li> <p> <u></u> <a href='https://www.stackhawk.com/blog/rails-xss-examples-and-prevention/'> <u>Rails</u> </a> <u></u> </p> </li> <li> <p> <u></u> <a href='https://www.stackhawk.com/blog/java-xss/'> <u>Java</u> </a> </p> </li> </ul> <p>Mozilla has an excellent set of explainers that break down the jargon from the standards into plain English. We'd recommend taking a look at their explainers on:</p> <ul> <li> <p> <u></u> <a href='https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Origin' target='_blank' rel='noopener noreferrer'> <u>Access-Control-Allow-Origin</u> </a> <u></u> </p> </li> <li> <p> <u></u> <a href='https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials' target='_blank' rel='noopener noreferrer'> <u>Access-Control-Allow-Credentials</u> </a> <u></u> </p> </li> <li> <p> <u></u> <a href='https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Headers' target='_blank' rel='noopener noreferrer'> <u>Access-Control-Allow-Headers</u> </a> <u></u> </p> </li> <li> <p> <u></u> <a href='https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Max-Age' target='_blank' rel='noopener noreferrer'> <u>Access-Control-Max-Age</u> </a> <u></u> </p> </li> <li> <p> <u></u> <a href='https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Expose-Headers' target='_blank' rel='noopener noreferrer'> <u>Access-Control-Expose-Headers</u> </a> <u></u> </p> </li> <li> <p> <u></u> <a href='https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Origin' target='_blank' rel='noopener noreferrer'> <u>Origin</u> </a> <u></u> </p> </li> </ul> <p>If you're an experienced pen-tester then you might also want to read <a href='https://root4loot.com/post/abusing_cors_origin/' target='_blank' rel='noopener noreferrer'>root4loot's article</a> on Abusing improper CORS origin validation. </p> <p> <i>This post was written by Tim Armstrong. Tim has worn many hats over the years, from 'Dark Lord of Network Operations' at Nerdalize to 'Lead Software Engineer' at De Beers. These days, he's going by 'Consultant Engineer &amp; Technical Writer.' You can find him on Twitter as @omatachyru, and at </i> <a href='https://plaintextnerds.com' target='_blank' rel='noopener noreferrer'> <i> <u>plaintextnerds.com</u> </i> </a> <i>.</i> </p>",
    "thumbnail_image": "https://next-learner-app.web.app/images/blogs/what-is-cors.jpg",
    "publish_date": "10 October, 2022"
  },
  {
    "id": 2,
    "title": "Why are you using firebase? What other options do you have to implement authentication?",
    "slug": "why-are-you-using-firebase",
    "short_details": "In the present era, user authentication is one of the most important requirements for Android apps.",
    "description": "<h1>Firebase Authentication</h1> <p>In the present era, user authentication is one of the most important requirements for Android apps. It is essential to authenticate users, and it is much harder if we have to write all this code on our own. This is done very easily with the help of Firebase.</p> <ul> <li>Being able to authenticate our users securely, it offers a customized experience to them based on their interests and preferences.</li> <li>We can ensure that they have no problems accessing their private data while using our app from multiple devices.</li> <li>Firebase Authentication provides all the server-side stuff for authenticating the user. Firebase Authentication becomes easy with SDK. It makes API easy to use.</li> <li>Firebase Authentication also provides some user interface libraries which enable screens for us when we are logging it.</li> <li>Firebase authentication supports authentication using a password, phone numbers, popular identity provider like Google, Facebook, and Twitter, etc.</li> <li>We can sign in users to our app by using the FirebaseUI. <ul> <li>It handles the UI flows for signing in user with an email address and password, phone numbers, and popular providers, including Google sign-In and Facebook Login.</li> <li>It can also handle cases like account recovery.</li> <li>It is not required to design a UI since it is already provided for us. It means we don't have to write the activities.</li> </ul></li> <li>We can also sign-in users using the Firebase Authentication SDK to integrate one or several sign-in methods into our app manually. </li> </ul> <img src='https://static.javatpoint.com/tutorial/firebase/images/firebase-authentication2.png' alt='Firebase Authentication'> <h2>Firebase UI Authentication Method</h2> <p>Firebase UI Authentication is a way to add a complete sign-in system to our app, where Firebase provides user interface to them. Firebase UI provides a drop-in auth solution which is used to implement authentication on mobile devices and websites.</p> <p>Firebase UI can be easily customized to fit with the rest of our app's visual style. It is open-source, so we are not constrained in modifying the user experience to meet our apps need.</p> <p>There are the following steps to use Firebase UI Authentication:</p> <ul> <li>Set up sign-in methods: <ul> <li>Enable authentication method in the firebase console. <ul> <li>For email address and password, phone number sign-in, and any identity providers.</li> </ul></li> <li>We have to complete the configuration if anyone requires for identity providers. <ul> <li>Setting our OAuth redirect URL. </li> </ul></li> </ul></li> <li>Customize the sign-in UI. <ul> <li>For customizing the sign-in and UI, we have to set some Firebase UI options or fork the code on GitHub.</li> </ul></li> <li>To perform the sign-in flow, use Firebase UI: <ul> <li>Import the Firebase UI library.</li> <li>Specify the sign-in method which we want to support.</li> <li>Initiate the Firebase UI sign-in flow. </li> </ul></li> </ul> <h2>Firebase SDK Authentication Method</h2> <p>This is another type of authentication method. The Firebase SDK Authentication provides methods for creating and managing users who use their email addresses and password to sign in. SDK also handles sending password reset emails.</p> <ul> <li>We can also provide phone number authentication using SDK <ul> <li>The authentication of users by sending SMS messages to their phones.</li> </ul> </li> <li>We can authenticate users by integrating with identity providers. <ul> <li>SDK provides methods which allow users to sign-in with their Google, Facebook, Twitter, and GitHub accounts. </li> </ul></li> <li>We can connect our app's existing sign-in system to the Firebase Authentication SDK and gain access to Firebase Real-time database and other Firebase services. </li><li>We can create a temporary anonymous account to use Firebase features, which requires authentication</li> without requiring users to sign-in first. </ul> <p>There are the following steps to use Firebase SDK Authentication:</p> <ul> <li>Set up sign-in methods: <ul> <li>We have to enable the authentication method in the Firebase console for an email address and password or phone number sign-in and any identity providers.</li> <li>We have to complete the configuration if anyone is required for identity providers. <ul> <li>Setting our OAuth redirect URL. </li> </ul></li> </ul></li> <li>Implementing UI flows for our sign-in methods: <ul> <li>For email signing, add screens which prompt the user to type their email addresses</li> <li>For phone number sign-in, add screens which prompt users to type their phone number, and after that, for the code from the SMS message they receive.</li> <li>For identity sign-in, implement the flow required by each provider.</li> </ul></li> <li>Passing the user's credentials to the Firebase Authentication SDK: <ul> <li>Pass the user's email address and password.</li> <li>Pass the OAuth token, which was acquired from the identity provider.</li> </ul></li> </ul> <h2>How Authentication Works?</h2> <ul> <li>We first get authentication credentials from the user to sign a user into our app. <ul> <li>Credentials can be the user's email address and password.</li> <li>The credential can be an OAuth token from an identity provider.</li> </ul></li> <li>We then pass these credentials to the Firebase Authentication SDK. Backend services will then verify those credentials and return a response to the client.</li> <li>After a successful sign in: <ul> <li>We can access the user's access to data stored in other Firebase products.</li> <li>We can access the user's basic profile information.</li> <li>We can use the provided authentication token to verify the identity of users in our own backend services.</li> </ul></li> <li>An authenticated user can read and write data to the Firebase Real-time Database and Cloud Storage. <ul> <li>We can control the access of those authenticated users by modifying the Firebase Database Rules and Storage Security Rules.</li> </ul></li> </ul> <h2>Users</h2> <ul> <li>A Firebase User object represents the account of a user who has signed up to the app in Firebase project. Apps have many registered users, and every app in a Firebase project shares a user data base.</li> <li>AFirebase User instance is independent of a Firebase Auth instance. It means we can have several references to different users within the same context and still call any of their method</li> <li>A Firebase User has a fixed set of basic properties such as Unique ID, Primary email address, Name, and a photo URL.</li> <li>Firstly, a user signs up to the app. The user's profile data is populated with the primary email address if using email/password auth, account information available by the provider if using identity auth, and anything we want if using custom auth.</li> <li>The user becomes the current user of the Auth instance when a user signs up or signs in.</li> <li>The Auth instance stops to keep a reference to the User object. And no longer persists it states when a user signs out: <ul> <li>No current user</li> <li>The user instance continues to be completely functional</li> <li>If we keep a reference to it, we can still access and update the user's data.</li> </ul></li> <li>Using listeners is the recommended way to track the current state of the Auth instance. <ul> <li>An Auth listener gets notified any time when something relevant happens to the Auth object.</li> </ul></li> </ul> <h2>User Lifecycle</h2> <ul> <li>An Auth listener gets notified in the following situation</li> <li>The Auth object finishes initializing, and a user was already signed in from a previous session or has been redirected from an identity provider's sign-in flow</li> <li>A user signs in.</li> <li>A user signs out.</li> <li>The current user's access token is refreshed: <ul> <li>The access token expires.</li> <li>The user changes their password.</li> <li>The user re-authenticates</li> </ul></li> </ul>",
    "thumbnail_image": "https://next-learner-app.web.app/images/blogs/why-are-you-using-firebase.jpg",
    "publish_date": "01 February, 2022"
  },
  {
    "id": 3,
    "title": "How does the private route work?",
    "slug": "how-does-the-private-route-work",
    "short_details": "In the present era, user authentication is one of the most important requirements for Android apps.",
    "description": "<p>Things are changing fast in WEB today, and <a href='https://reactrouter.com/'><code>react-router</code></a> v6 is in beta already and around the corner. 🤔</p> <blockquote> <p>This is just for learning purposes only, react-router v6 is still in beta, use at your own risk</p> </blockquote> <p>Private routes in v5 and below were done in a specific way using a custom component mostly named <code>PrivateRoute</code> that was most of the times just a wrapper and composition of basic <code>Route</code> and <code>Redirect</code> e.g.<br> </p> <p>But taking a look at v6 docs it seems that things changed a little bit, and we need to think a little bit different about it.</p> <blockquote> <p>For info about all API reference see the <a href='https://github.com/remix-run/react-router/blob/c13b66939ef48eacf7067f7aec4752777be8b17c/docs/api-reference.md'>link</a></p> </blockquote> <p>Let's move on.</p> <p>Some things that we used to create <code>PrivateRoute</code> have changed a little bit</p> <ul> <li> <code>Redirect</code> is now <a href='https://github.com/remix-run/react-router/blob/c13b66939ef48eacf7067f7aec4752777be8b17c/docs/api-reference.md#navigate'><code>Navigate</code></a> </li> <li> <a href='https://github.com/remix-run/react-router/blob/c13b66939ef48eacf7067f7aec4752777be8b17c/docs/api-reference.md#routes-and-route'><code>Route</code></a> props changed and is just a stub component now</li> <li>A new component <a href='https://github.com/remix-run/react-router/blob/c13b66939ef48eacf7067f7aec4752777be8b17c/docs/api-reference.md#routes-and-route'><code>Routes</code></a> appearead</li> </ul> <p>So as you can see, no more render props or component prop.<br> You need to pass a direct JSX element (don't worry about performance if you do)</p> <p>Ok now let's take a look at <code>Route</code> component <a href='https://github.com/remix-run/react-router/blob/c13b66939ef48eacf7067f7aec4752777be8b17c/packages/react-router/index.tsx#L198-L209'>source code</a><br> </p> <p>Wait a minute where is the code? 👀 Well actually the parent component <code>Routes</code> will use the <code>Route</code> just as a host for the props and children, and do nothing more with the <code>Route</code></p> <blockquote> <p>For more info about <code>Routes</code> implementation see <a href='https://github.com/remix-run/react-router/blob/c13b66939ef48eacf7067f7aec4752777be8b17c/packages/react-router/index.tsx#L262-L274'>link</a></p> </blockquote> <p>So how we do implement our <code>PrivateRoute</code> now? 🤔 If we do some adjustments to <code>PrivateRoute</code> props, it will look like this<br> </p> <p>But this will not work. <code>Routes</code> will just take the props of <code>PrivateRoute</code> and ignore it's body totally. Even a console.log inside <code>PrivateRoute</code> will not be shown.</p> <p>So what we do? 🤔 We do some more adjustments to <code>PrivateRoute</code><br> </p> <p>As you can see we changed <code>Redirect</code> to <code>Navigate</code>, and just return <code>children</code> if user is authenticated. And the usage of it also changes a little bit<br> </p> <p>As you can see <code>PrivateRoute</code> also moves to <code>element</code> prop.</p> <blockquote> <p>The implementation of <code>PrivateRoute</code> can be done in multiple ways.</p> </blockquote> <p>Here is a different implementation of <code>PrivateRoute</code> using <a href='https://github.com/remix-run/react-router/blob/c13b66939ef48eacf7067f7aec4752777be8b17c/docs/api-reference.md#outlet'><code>Outlet</code></a><br> </p> <p>The pros of this is that you can put multiple private sub routes under same route.</p> <p>For a full example see this <a href='https://codesandbox.io/s/react-router-v6-security-gojb0'>Codesandbox</a></p> <p>That's all for today. Happy coding! 🎉 🎊 ✨ </p> <p>Keep your users secure!</p>",
    "thumbnail_image": "https://next-learner-app.web.app/images/blogs/how-does-the-private-route-work.jfif",
    "publish_date": "21 September, 2022"
  },
  {
    "id": 4,
    "title": "What is Node? How does Node work?",
    "slug": "what-is-node-how-does-node-work",
    "short_details": "As you've possibly already come across by now, CORS is an acronym for Cross-Origin Resource Sharing, but what does that actually mean?",
    "description": "<p>Node.js is an open-source backend javascript runtime environment. It is a used as backend service where javascript works on the server-side of the application. This way javascript is used on both frontend and backend. Node.js runs on chrome v8 engine which converts javascript code into machine code, it is highly scalable, lightweight, fast, and data-intensive.</p><p><strong>Working of Node.js: </strong>Node.js accepts the request from the clients and sends the response, while working with the request node.js handles them with a single thread. To operate I/O operations or requests node.js use the concept of threads. Thread is a sequence of instructions that the server needs to perform. It runs parallel on the server to provide the information to multiple clients. Node.js is an event loop single-threaded language. It can handle concurrent requests with a single thread without blocking it for one request.</p><p>Node.js basically works on two concept</p><ul><li>Asynchronous</li><li>Non-blocking I/O</li></ul><p><strong>Non-blocking I/o: </strong>Non-blocking i/o &nbsp;means working with multiple requests without blocking the thread for a single request. I/O basically interacts with external systems such as files, databases. Node.js is not used for CPU-intensive work means for calculations, video processing because a single thread cannot handle the CPU works.</p><p><strong>Asynchronous: </strong>Asynchronous is executing a callback function. The moment we get the response from the other server or database it will execute a callback function. Callback functions are called as soon as some work is finished and this is because the node.js uses an event-driven architecture. The single thread doesn’t work with the request instead it sends the request to another system which resolves the request and it is accessible for another request.</p><p>To implement the concept of the system to handle the request &nbsp;node.js uses the concept of Libuv.</p><p>Libuv is an open-source library built-in C. It has a strong focus on asynchronous and &nbsp;I/O, this gives node access to the underlying computer operating system, file system, and networking.</p><p>Libuv implements two extremely important features of node.js &nbsp;</p><ul><li>Event loop</li><li>Thread pool</li></ul><p><strong>Event loop: </strong>The event loop contains a single thread and is responsible for handling easy tasks like executing callbacks and network I/O. When the program is to initialize all the top-level code is executed, the code is not in the callback function. All the applications code that is inside callback functions will run in the event loop. EventLoop is the heart of node.js. When we start our node application the event loop starts running right away. Most of the work is done in the event loop.</p><p>Nodejs use event-driven-architecture.</p><ul><li>Events are emitted.</li><li>Event loop picks them up.</li><li>Callbacks are called.</li></ul><p><strong>Event queue: </strong>As soon as the request is sent the thread places the request into a queue. It is known as an event queue. The process like app receiving HTTP request or server or a timer will emit event as soon as they are done with the work and event loop will pick up these events and call the callback functions that are associated with each event and response is sent to the client.&nbsp;</p><p>The event loop is an indefinite loop that continuously receives the request and processes them. It checks the queue and waits for the incoming request indefinitely.</p><p><strong>Thread pool: </strong>Though node.js is single-threaded it internally maintains a thread pool. When non-blocking requests are accepted there are processed in an event loop, but while accepting blocking requests it checks for available threads in a thread pool, assigns a thread to the client’s request which is then processed and send back to the event loop, and response is sent to the respective client.</p><p>The thread pool size can be change:</p><p>process.env.UV_THREADPOOL_SIZE = 1;</p><<img src='https://media.geeksforgeeks.org/wp-content/uploads/20210916203407/WorkingofNodejs1.png' srcset='https://media.geeksforgeeks.org/wp-content/uploads/20210916203407/WorkingofNodejs1.png,' sizes='100vw'>",
    "thumbnail_image": "https://next-learner-app.web.app/images/blogs/what-is-node-how-does-node-work.png",
    "publish_date": "10 July, 2022"
  }
]